/* 
!!! Automatically generated by
../common/link_generators/gen_tlm_sender.py
Do not edit it manually. 
*/
#include "main.h"
#include "message.hpp"
#include "param_registry.hpp"
#include "global_flags.h"
#include "this_comp_id.h"
#include "tlm_sender.hpp"

/*
 ******************************************************************************
 * DEFINES
 ******************************************************************************
 */

/*
 ******************************************************************************
 * EXTERNS
 ******************************************************************************
 */
#include "icr_channel.hpp"
extern mavChannelIcr icr_channel;

extern mavlink_attitude_t mavlink_out_attitude_struct;
extern mavlink_global_position_int_t mavlink_out_global_position_int_struct;
extern mavlink_highres_imu_t mavlink_out_highres_imu_struct;
extern mavlink_hil_state_t mavlink_out_hil_state_struct;
extern mavlink_nav_controller_output_t mavlink_out_nav_controller_output_struct;
extern mavlink_raw_imu_t mavlink_out_raw_imu_struct;
extern mavlink_raw_pressure_t mavlink_out_raw_pressure_struct;
extern mavlink_rc_channels_raw_t mavlink_out_rc_channels_raw_struct;
extern mavlink_rc_channels_scaled_t mavlink_out_rc_channels_scaled_struct;
extern mavlink_scaled_imu_t mavlink_out_scaled_imu_struct;
extern mavlink_scaled_pressure_t mavlink_out_scaled_pressure_struct;
extern mavlink_sys_status_t mavlink_out_sys_status_struct;
extern mavlink_vfr_hud_t mavlink_out_vfr_hud_struct;


/*
 ******************************************************************************
 * PROTOTYPES
 ******************************************************************************
 */
/* sending function */
typedef void (*send_t)(void);

typedef struct tlm_registry_t {
  /* how much to sleep */
  systime_t next_dealine;
  /* pointer to period value in global parameters structure */
  uint32_t const *sleepperiod;
  /* sending function */
  const send_t sender;
}tlm_registry_t;

static void send_attitude(void);
static void send_gps_int(void);
static void send_highres_imu(void);
static void send_hil_state(void);
static void send_nav_output(void);
static void send_raw_imu(void);
static void send_raw_press(void);
static void send_rc_raw(void);
static void send_rc_scaled(void);
static void send_scal_imu(void);
static void send_scal_press(void);
static void send_sys_status(void);
static void send_vfr_hud(void);

/*
 ******************************************************************************
 * GLOBAL VARIABLES
 ******************************************************************************
 */

static uint32_t mailbox_overflow = 0;
static uint32_t mail_undelivered = 0;
static bool pause_flag = false;

static mavMail attitude_mail(NULL);
static mavMail global_position_int_mail(NULL);
static mavMail highres_imu_mail(NULL);
static mavMail hil_state_mail(NULL);
static mavMail nav_controller_output_mail(NULL);
static mavMail raw_imu_mail(NULL);
static mavMail raw_pressure_mail(NULL);
static mavMail rc_channels_raw_mail(NULL);
static mavMail rc_channels_scaled_mail(NULL);
static mavMail scaled_imu_mail(NULL);
static mavMail scaled_pressure_mail(NULL);
static mavMail sys_status_mail(NULL);
static mavMail vfr_hud_mail(NULL);

/* autoinitialized array */
static tlm_registry_t Registry[] = {
    {11, NULL, send_attitude},
    {12, NULL, send_gps_int},
    {13, NULL, send_highres_imu},
    {14, NULL, send_hil_state},
    {15, NULL, send_nav_output},
    {16, NULL, send_raw_imu},
    {17, NULL, send_raw_press},
    {18, NULL, send_rc_raw},
    {19, NULL, send_rc_scaled},
    {20, NULL, send_scal_imu},
    {21, NULL, send_scal_press},
    {22, NULL, send_sys_status},
    {23, NULL, send_vfr_hud},
};

/*
 *******************************************************************************
 *******************************************************************************
 * LOCAL FUNCTIONS
 *******************************************************************************
 *******************************************************************************
 */
static void send_attitude(void){
  msg_t status = RDY_RESET;
  if (attitude_mail.free()){
    attitude_mail.fill(&mavlink_out_attitude_struct, COMP_ID, MAVLINK_MSG_ID_ATTITUDE);
    status = icr_channel.post(&attitude_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_gps_int(void){
  msg_t status = RDY_RESET;
  if (global_position_int_mail.free()){
    global_position_int_mail.fill(&mavlink_out_global_position_int_struct, COMP_ID, MAVLINK_MSG_ID_GLOBAL_POSITION_INT);
    status = icr_channel.post(&global_position_int_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_highres_imu(void){
  msg_t status = RDY_RESET;
  if (highres_imu_mail.free()){
    highres_imu_mail.fill(&mavlink_out_highres_imu_struct, COMP_ID, MAVLINK_MSG_ID_HIGHRES_IMU);
    status = icr_channel.post(&highres_imu_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_hil_state(void){
  msg_t status = RDY_RESET;
  if (hil_state_mail.free()){
    hil_state_mail.fill(&mavlink_out_hil_state_struct, COMP_ID, MAVLINK_MSG_ID_HIL_STATE);
    status = icr_channel.post(&hil_state_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_nav_output(void){
  msg_t status = RDY_RESET;
  if (nav_controller_output_mail.free()){
    nav_controller_output_mail.fill(&mavlink_out_nav_controller_output_struct, COMP_ID, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT);
    status = icr_channel.post(&nav_controller_output_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_raw_imu(void){
  msg_t status = RDY_RESET;
  if (raw_imu_mail.free()){
    raw_imu_mail.fill(&mavlink_out_raw_imu_struct, COMP_ID, MAVLINK_MSG_ID_RAW_IMU);
    status = icr_channel.post(&raw_imu_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_raw_press(void){
  msg_t status = RDY_RESET;
  if (raw_pressure_mail.free()){
    raw_pressure_mail.fill(&mavlink_out_raw_pressure_struct, COMP_ID, MAVLINK_MSG_ID_RAW_PRESSURE);
    status = icr_channel.post(&raw_pressure_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_rc_raw(void){
  msg_t status = RDY_RESET;
  if (rc_channels_raw_mail.free()){
    rc_channels_raw_mail.fill(&mavlink_out_rc_channels_raw_struct, COMP_ID, MAVLINK_MSG_ID_RC_CHANNELS_RAW);
    status = icr_channel.post(&rc_channels_raw_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_rc_scaled(void){
  msg_t status = RDY_RESET;
  if (rc_channels_scaled_mail.free()){
    rc_channels_scaled_mail.fill(&mavlink_out_rc_channels_scaled_struct, COMP_ID, MAVLINK_MSG_ID_RC_CHANNELS_SCALED);
    status = icr_channel.post(&rc_channels_scaled_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_scal_imu(void){
  msg_t status = RDY_RESET;
  if (scaled_imu_mail.free()){
    scaled_imu_mail.fill(&mavlink_out_scaled_imu_struct, COMP_ID, MAVLINK_MSG_ID_SCALED_IMU);
    status = icr_channel.post(&scaled_imu_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_scal_press(void){
  msg_t status = RDY_RESET;
  if (scaled_pressure_mail.free()){
    scaled_pressure_mail.fill(&mavlink_out_scaled_pressure_struct, COMP_ID, MAVLINK_MSG_ID_SCALED_PRESSURE);
    status = icr_channel.post(&scaled_pressure_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_sys_status(void){
  msg_t status = RDY_RESET;
  if (sys_status_mail.free()){
    sys_status_mail.fill(&mavlink_out_sys_status_struct, COMP_ID, MAVLINK_MSG_ID_SYS_STATUS);
    status = icr_channel.post(&sys_status_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}

static void send_vfr_hud(void){
  msg_t status = RDY_RESET;
  if (vfr_hud_mail.free()){
    vfr_hud_mail.fill(&mavlink_out_vfr_hud_struct, COMP_ID, MAVLINK_MSG_ID_VFR_HUD);
    status = icr_channel.post(&vfr_hud_mail, TIME_IMMEDIATE);
    if (status != RDY_OK)
      mailbox_overflow++;
  }
  else
    mail_undelivered++;
}


/**
 *
 */
static systime_t get_sleep_time(tlm_registry_t *R, size_t len){
  systime_t t;
  uint32_t i;

  t = R[0].next_dealine; /* just take first available */
  i = 0;
  while (i < len){
    /* determine minimum sleep time */
    if (t > R[i].next_dealine)
      t = R[i].next_dealine;
    i++;
  }
  return t;
}

/**
 * refresh deadlines according sleeped time
 */
void refresh_deadlines(tlm_registry_t *R, size_t len, systime_t t){
  uint32_t i = 0;
  while (i < len){
    R[i].next_dealine -= t;
    if (R[i].next_dealine == 0){
      if (*(R[i].sleepperiod) != SEND_OFF){
        R[i].next_dealine = *(R[i].sleepperiod);
        R[i].sender();
      }
      else
        R[i].next_dealine = 1200;
    }
    i++;
  }
}

/**
 * Listen events with new parameters
 */
static WORKING_AREA(TlmSenderThreadWA, 200);
static msg_t TlmSenderThread(void *arg) {
  chRegSetThreadName("TLM_Scheduler");
  (void)arg;
  systime_t t; /* milliseconds to sleep to next deadline */

  while (!GlobalFlags.messaging_ready)
    chThdSleepMilliseconds(50);

  setGlobalFlag(GlobalFlags.tlm_link_ready);

  /* main loop */
  while (!chThdShouldTerminate()){
    if (true == pause_flag)
      chThdSleepMilliseconds(100);
    else{
      t = get_sleep_time(Registry, sizeof(Registry)/sizeof(Registry[0]));
      chThdSleepMilliseconds(t);
      refresh_deadlines(Registry, sizeof(Registry)/sizeof(Registry[0]), t);
    }
  }

  clearGlobalFlag(GlobalFlags.tlm_link_ready);
  chThdExit(0);
  return 0;
}

/** 
 *
 */
static void load_parameters(void) {
  param_registry.valueSearch("T_attitude", &(Registry[0].sleepperiod));
  param_registry.valueSearch("T_gps_int", &(Registry[1].sleepperiod));
  param_registry.valueSearch("T_highres_imu", &(Registry[2].sleepperiod));
  param_registry.valueSearch("T_hil_state", &(Registry[3].sleepperiod));
  param_registry.valueSearch("T_nav_output", &(Registry[4].sleepperiod));
  param_registry.valueSearch("T_raw_imu", &(Registry[5].sleepperiod));
  param_registry.valueSearch("T_raw_press", &(Registry[6].sleepperiod));
  param_registry.valueSearch("T_rc_raw", &(Registry[7].sleepperiod));
  param_registry.valueSearch("T_rc_scaled", &(Registry[8].sleepperiod));
  param_registry.valueSearch("T_scal_imu", &(Registry[9].sleepperiod));
  param_registry.valueSearch("T_scal_press", &(Registry[10].sleepperiod));
  param_registry.valueSearch("T_sys_status", &(Registry[11].sleepperiod));
  param_registry.valueSearch("T_vfr_hud", &(Registry[12].sleepperiod));
}

/*
 *******************************************************************************
 * EXPORTED FUNCTIONS
 *******************************************************************************
 */
/**
 *
 */
TlmSender::TlmSender(void){
  return;
}

/**
 *
 */
void TlmSender::start(void){

  load_parameters();

  this->worker = chThdCreateStatic(TlmSenderThreadWA,
                 sizeof(TlmSenderThreadWA),
                 TELEMTRYPRIO,
                 TlmSenderThread,
                 NULL);
  chDbgCheck(NULL != this->worker, "can not allocate memory");

  pause_flag = false;
}

/**
 *
 */
void TlmSender::stop(void){
  pause_flag = true;
  chThdTerminate(worker);
  chThdWait(worker);
}

/**
 *
 */
void TlmSender::pause(void){
  pause_flag = true;
}

/**
 *
 */
void TlmSender::resume(void){
  pause_flag = false;
}
